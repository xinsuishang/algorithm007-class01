# Week_04
874 
做完 874 题时，一直不能 AC

看完优秀题解，发现思路上说就是基本一致的。
所以问题出现在了如何优化自己的代码

在发现了实现逻辑正确但是超过时间限制的时候，需要对当前代码中耗时较多的逻辑替换。

例如原代码中我采用的是每次遍历所有障碍数组来计算最小移动距离，O(n)
在优秀题解中，采用的对障碍数组进行处理，每次采用 O(1)的contains

这个处理逻辑是原代码和题解中最大的差别。

另一个重点，如果将现实问题抽象成抽象的数据结构和代码逻辑，这是一大弱点。

以上：
    1. 优化代码，主要是降低时间复杂度
    2. 抽象，将现实问题往抽象的数据结构上带入



使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方
也就是题目 153. 寻找旋转排序数组中的最小值 利用 log（n）时间复杂度的二分查找算法

暴力求解：因为是升序，所以遍历前者大于后者
二分查找：mid 会落在左边升序，或者右边升序中
        在左边升序，mid > left ,mid > right。而最小值是在右边升序，所以改变左边边界
        落在右边升序 不满足同时大于两个边界，考虑 right 刚好在最小值，所以不用减一

        还有就是当 left 和 righ在同一升序区间的时候，也不满足上诉判断条件，但只改变右边界
        反证：只有当 mid 是落在左边的升序区间是才改变左边界，其余情况都只改变右边界，因为题目求得是最小值


```
class Solution {
    func findMin(_ nums: [Int]) -> Int {
        var left = 0 
        var right = nums.count - 1

        while left < right {
            let mid = left + (right - left) / 2
            // = 的时候就是 left + 1 = right
            // 
            if nums[mid] >= nums[left] && nums[mid] > nums[right] {
                left = mid + 1
            }else {
                // 不减一，因为包含了等于的情况
                right = mid
            }
        }
        return nums[right]
    }
}
```