# 解码方法 一条包含字母 A-Z 的消息通过以下方式进行了编码 'A' -> 1，'B' -> 2,...,'Z' -> 26 ,给定一个只包含数字的非空字符串，请计算解码方法的总数。
# "226" 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) ; "12":它可以解码为 "AB"（1 2）或者 "L"（12）。
# 爬楼梯问题：dp[n] = dp[n-1]+dp[n-2]，最后一步走一步或者最后一步走两步，退化到了求dp[i-1]和dp[i-2],依次类推
# 每次解码一个数字或者两个数字，用dp[i]表示解码字符串s[:i]（包含s[0],s[1],...,s[i-1])的方法总数,考虑dp[i+1]的计算，即解码s[:i+1]的可能情形：
# 一维状态数组 dp=[0,0,...,0] 
# 状态转移方程：
# 如果s[i] = '0',这时看s[i-1],如果s[i-1]='1'或'2',此时dp[i+1]=dp[i-1]，因为上一位和本位置结合在一起，相当于走两级台阶，否则的话，返回0
# 如果s[i] != '0',此时当s[i-1]='1'时，s[i]可以是任意的，当s[i-1]='2',s[i]只能从0到6，在这种情况下dp[i+1]=dp[i]+dp[i−1]，其余s[i]!=0的情况，相当于只能跨一步台阶，d[i+1]=d[i]
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        if not s or s[0] = '0':
            return 0
        dp = [[0]*(n+1)]
        dp[0]=dp[1]=1
        for i in range(n):
            if s[i] == '0':
                if s[i-1] = '1' or s[i-1] = '2':
                    dp[i+1] = dp[i-1]
                else:
                    return 0
            else:
                if s[i-1]=='1' or (s[i-1]=='2'and'1'<=s[i]<='6'):
                    dp[i+1] = dp[i] + dp[i-1]
                else:
                    dp[i+1] = dp[i]
        return dp[n]