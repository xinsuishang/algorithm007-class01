# 青蛙过河
# 河流被分成x个单元格，并且每一个单元格内都有可能放有石子，青蛙可以跳上石头，但是不可以跳入水中
# 给定石子的位置列表，判断青蛙能否成功过河(能否最后一步跳到最后一个石子上)，
# 开始的时候，青蛙默认已经站在第一个石子上，并可以假定它第一步只能挑一个单位(即只能从单元格1跳到单元格2)
# 如果青蛙上一步跳了k步，那么接下来它的跳跃距离只能选择1，k，k+1个单位，青蛙只能向终点方向跳跃

# 举例1：[0,1,3,5,6,8,12,17]  总共有8个石子，第一个石子在序号为0的位置，第2个石子在序号为1的位置，以此类推，最后一个石子在序号为17的位置
# 青蛙可以成功跳过河，(i,j) 代表跳i个单位，j代表跳跃过程，则有
# (1,0-1),(2,1-3),(2,3-5),(1,5-6),(2,6-8),此时跳跃的距离是1,2,3，不能从(8-12),不行
# (1,0-1),(2,1-3),(2,3-5),(3,5-8),(4,8-12),(5,12-17)可以跳跃
# 举例2：[0,1,2,3,4,8,9,11]  不能过原因：4-8之间距离过大
# (1,0-1),(1,1-2),(1,2-3),(1,3-4),此时跳跃距离为0,1,2，不能从(4,8),错误
# (1,0-1),(2,1-3),(3,3-5) 没有序号为5的石头存在，错误
# (1,0-1),(1,1-2),(2,2-4),(3,4-7)没有序号为7的格子存在,错误
# 状态数组 dp{a:b},j键代表石头位置，值代表的是该位置所要迈出的步长
# 如果dp中石头的最后一个位置，值非空，则可以到达最后一个石头，反之不能
# 边界条件：1.石头是空值，返回0；2.根据题目，到达1位置，其步长只能需要1
class Solution(object):
    def canCross(self, stones):
        # 边界条件
        if not stones: return True
        # 新建dict，值为stone,键是一个集合
        dp = {x:set() for x in stones}
        # 第一个石头，只能走1步
        dp[stones[0]].add(1)
        # 遍历所有的石头，并遍历不同石头可以走的步数
        for stone in stones:
            for step in dp[stone]:
                # 只能向前走
                if step <= 0:
                    continue
                # 如果石头+步数在dp中，存在此键
                if stone + step in dp:
                    # 更新(石头+步数)对应的键值，这一步分别可以走step-1,step+1,step，这三步
                    dp[stone+step].update({step-1,step,step+1})
                # 如果最后一个位置值不是空的，说明已经到达该位置，那么成功，否则不成功
            if dp[stones[-1]]:
                return True
        return False