//一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。
// 给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以
//假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。
// 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。
//
//
// 请注意：
// 石子的数量 ≥ 2 且 < 1100；
// 每一个石子的位置序号都是一个非负整数，且其 < 231；
// 第一个石子的位置永远是0。

//leetcode submit region begin(Prohibit modification and deletion)
/*
使用二维数组的动态规划
dp[i][k]表示能否由前面的某一个石头j通过跳k步到达当前这个石头i
这个j的范围是[1, i-1]
当前石头到下一块石头的距离就必须是这个 k - 1 || k || k + 1
k是青蛙从上一块石头跳到当前石头的距离
由此可得状态转移方程：dp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1]
*/
class Solution {
    public boolean canCross(int[] stones) {
        int len = stones.length;
        // 青蛙在第一个位置只能跳一格
        if (stones[1] != 1) {
            return false;
        }
        // 构造一个dp table,记录前一个石头能否到达当前石头
        boolean[][] dp = new boolean[len][len+1];
        dp[0][0] = true;
        // 青蛙是可以跳到第一块石头的，此时k为1
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                // k值是当前石头与之前石头的距离
                int k = stones[i] - stones[j];
            /*
                为什么有这么个判断？
                因为其他石头跳到第i个石头跳的步数k必定满足k <= i
                这又是为什么？
                1、比如 nums = [0,1,3,5,6,8,12,17]
                那么第0个石头跳到第1个石头，步数肯定为1，
                然后由于后续最大的步数是k+1，因此第1个石头最大只能跳2个单位
                因此如果逐个往上加，那么第2 3 4 5 ...个石头最多依次跳跃的步数是3 4 5 6...
                2、 第i个石头能跳的最大的步数是i+1，
                那么就意味着其他石头j跳到第i个石头的最大步数只能是i或者j+1
                而这个k是其他石头跳到i石头上来的，因此k <= i （或者是k <= j + 1）
            */
                if (k <= i) {
                    dp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1];
                    //提前结束循环直接返回结果
                    if (i == len - 1 && dp[i][k]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
//leetcode submit region end(Prohibit modification and deletion)
